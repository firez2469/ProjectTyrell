using DBModels;
using System.Collections.Generic;
using System.Threading.Tasks;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.WSA;

public class RandomNationInitializer : MonoBehaviour
{
    [SerializeField]
    private Transform tilesParent;
    private Tile[] tiles;

    [SerializeField]
    private int nationsCount = 20;
    [SerializeField]
    private float nationsMinDist = 0.25f;
    [SerializeField]
    private int totalWorldPopulation = 1_000_000_000;
    [SerializeField]
    private bool isInitialized = false;

    private int[] popDist;


    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {


    }

    public async Task CreateRandomNationsAsync()
    {
        int gameId = MapDBInitializer.GameId;
        // Get all in world tiles.
        tiles = tilesParent.GetComponentsInChildren<Tile>();
        // Clear DB of previous nations information.
        DatabaseControl.DeleteNationsExcept(1);
        DatabaseControl.ResetAllTileOwnerships(gameId);

        foreach (Tile tile in tiles)
        {
            tile.controllerId = -1;
        }

        // Start generation.

        // Use all tiles
        List<Tile> availableTiles = new List<Tile>();
        foreach (Tile tile in tiles)
        {
            availableTiles.Add(tile);
        }

        List<TileDataLite> availableTileData = new List<TileDataLite>();
        foreach (Tile tile in availableTiles)
        {
            availableTileData.Add(new TileDataLite { tile = tile, position = tile.transform.position });
        }

        List<Tile> chosenCapitals = new List<Tile>();
        System.Random rng = new System.Random();

        // Select from all tiles
        for (int i = 0; i < nationsCount && availableTiles.Count > 0; i++)
        {
            Tile selected = null;
            int attempts = 0;

            while (attempts < 1000)
            {
                Tile candidate = availableTiles[rng.Next(availableTiles.Count)];

                bool isFarEnough = true;

                foreach (Tile existing in chosenCapitals)
                {
                    float dist = Vector3.Distance(candidate.transform.position, existing.transform.position);
                    if (dist < nationsMinDist)
                    {
                        isFarEnough = false;
                        break;
                    }
                }

                if (isFarEnough)
                {
                    selected = candidate;
                    break;
                }
                attempts++;
            }

            if (selected != null)
            {
                chosenCapitals.Add(selected);
                availableTiles.Remove(selected);
            }
        }



        Debug.Log("Step 1 of Nation Generation Complete!");

        // Step 2: Spread ownership from each capital until no valid neighbor is left
        Queue<(Tile tile, int nationId)> frontier = new Queue<(Tile, int)>();
        HashSet<Tile> visited = new HashSet<Tile>();
        
        // Initialize frontier with all capitals
        for (int i = 0; i < chosenCapitals.Count; i++)
        {
            Tile capital = chosenCapitals[i];
            capital.controllerId = i;
            frontier.Enqueue((capital, i));
            visited.Add(capital);
        }

        while (frontier.Count > 0)
        {
            int currentLevelSize = frontier.Count;

            // Process all nodes in this level (BFS layer)
            for (int i = 0; i < currentLevelSize; i++)
            {
                var (current, nationId) = frontier.Dequeue();

                foreach (string neighborStr in current.neighbors)
                {
                    if (int.TryParse(neighborStr, out int neighborId))
                    {
                        Tile neighbor = System.Array.Find(tiles, t => int.Parse(t.Id) == neighborId);
                        if (neighbor != null &&
                            !visited.Contains(neighbor) &&
                            (neighbor.controllerId == -1 || neighbor.controllerId == 0 || neighbor.controllerId == 1))
                        {
                            neighbor.controllerId = nationId;
                            frontier.Enqueue((neighbor, nationId));
                            visited.Add(neighbor);
                        }
                    }
                }
            }
        }



        Debug.Log("Step 2 of Nation Generation Complete!");

        // Step 3 & 4: Create DB Nations
        DBNation[] nations = new DBNation[nationsCount];
        for (int i = 0; i < chosenCapitals.Count; i++)
        {
            string name = $"Nation {i + 1}";
            string desc = $"Autogenerated nation #{i + 1}";
            int id = DatabaseControl.CreateNewNation(name, desc, gameId);
            nations[i] = new DBNation
            {
                name = name,
                description = desc,
                gameId = gameId,
                id = id
            };
        }
        

        Debug.Log("Step 3 & 4 of Nation Generation Complete!");

        // Step 5: Push tile ownership to DB
        await Task.Run(() =>
        {
            foreach (Tile tile in tiles)
            {
                if (tile.controllerId != -1)
                {
                    DatabaseControl.UpdateTileOwnership(int.Parse(tile.Id), gameId, tile.controllerId);
                }
            }
        });

        Debug.Log($"Initialized {chosenCapitals.Count} nations.");
    }

    public async Task UpdateTileOwnershipFromDatabaseAsync(int gameId)
    {
        await Task.Run(() =>
        {
            tiles = tilesParent.GetComponentsInChildren<Tile>();

            foreach (Tile tile in tiles)
            {
                DBTile dbTile = DatabaseControl.GetTileById(int.Parse(tile.Id), gameId);
                if (dbTile != null)
                {
                    int ownerId = dbTile.owner;
                    UnityMainThreadDispatcher.Enqueue(() =>
                    {
                        tile.controllerId = ownerId;
                    });
                }
            }
        });

        Debug.Log("Tile ownerships synced from database.");
    }


    // Update is called once per frame
    async void Update()
    {
        if (!isInitialized)
        {
            isInitialized = true;
            await CreateRandomNationsAsync();
        }
    }


    public struct TileDataLite
    {
        public Tile tile;
        public Vector3 position;
    }


}