using DBModels;
using System.Collections.Generic;
using System.Threading.Tasks;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.WSA;

public class RandomNationInitializer : MonoBehaviour
{
    [SerializeField]
    private Transform tilesParent;
    private Tile[] tiles;

    [SerializeField]
    private int nationsCount = 20;
    [SerializeField]
    private float nationsMinDist = 0.25f;
    [SerializeField]
    private int totalWorldPopulation = 1_000_000_000;

    private bool isInitialized = false;
    private bool isLoaded = false;
    
    private int[] popDist;


    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        isInitialized = !MapDBInitializer.InstantLoad;

    }

    public async Task CreateRandomNationsAsync()
    {
        int gameId = MapDBInitializer.GameId;

        // Get all in-world tiles
        tiles = tilesParent.GetComponentsInChildren<Tile>();
        Dictionary<int, Tile> tileByGameId = new();
        foreach (Tile t in tiles)
            tileByGameId[int.Parse(t.Id)] = t;

        // Reset tile data and DB state
        DatabaseControl.DeleteNationsExcept(1);
        DatabaseControl.ResetAllTileOwnerships(gameId);

        foreach (Tile tile in tiles)
            tile.controllerId = -1;

        // Step 1: Select capitals
        List<Tile> availableTiles = new(tiles);
        List<Tile> chosenCapitals = new();
        System.Random rng = new();

        for (int i = 0; i < nationsCount && availableTiles.Count > 0; i++)
        {
            Tile selected = null;
            int attempts = 0;

            while (attempts < 1000)
            {
                Tile candidate = availableTiles[rng.Next(availableTiles.Count)];
                bool isFarEnough = true;

                foreach (Tile existing in chosenCapitals)
                {
                    if (Vector3.Distance(candidate.transform.position, existing.transform.position) < nationsMinDist)
                    {
                        isFarEnough = false;
                        break;
                    }
                }

                if (isFarEnough)
                {
                    selected = candidate;
                    break;
                }

                attempts++;
            }

            if (selected != null)
            {
                chosenCapitals.Add(selected);
                availableTiles.Remove(selected);
            }
        }

        Debug.Log("Step 1: Capitals selected.");

        // Step 2: Ownership assignment via BFS
        Queue<(Tile, int)> frontier = new();
        HashSet<Tile> visited = new();

        for (int i = 0; i < chosenCapitals.Count; i++)
        {
            Tile capital = chosenCapitals[i];
            capital.controllerId = i;
            frontier.Enqueue((capital, i));
            visited.Add(capital);
        }

        while (frontier.Count > 0)
        {
            var (current, nationId) = frontier.Dequeue();

            foreach (string neighborStr in current.neighbors)
            {
                if (int.TryParse(neighborStr, out int neighborId) &&
                    tileByGameId.TryGetValue(neighborId, out Tile neighbor) &&
                    !visited.Contains(neighbor))
                {
                    neighbor.controllerId = nationId;
                    frontier.Enqueue((neighbor, nationId));
                    visited.Add(neighbor);
                }
            }
        }

        Debug.Log("Step 2: Ownership BFS complete.");

        // Step 3 & 4: Create nations in DB
        DBNation[] nations = new DBNation[nationsCount];
        for (int i = 0; i < chosenCapitals.Count; i++)
        {
            string name = $"Nation {i + 1}";
            string desc = $"Autogenerated nation #{i + 1}";
            int id = DatabaseControl.CreateNewNation(name, desc, gameId);
            nations[i] = new DBNation { name = name, description = desc, gameId = gameId, id = id };
        }

        Debug.Log("Step 3 & 4: Nations created in database.");

        // Step 5: Push ownership to DB
        await Task.Run(() =>
        {
            foreach (Tile tile in tiles)
            {
                if (tile.controllerId != -1)
                {
                    DatabaseControl.UpdateTileOwnership(int.Parse(tile.Id), gameId, tile.controllerId);
                }
            }
        });

        Debug.Log("Step 5: Tile ownership pushed to DB.");

        // Step 6: BFS from capitals to measure distance for population falloff
        Dictionary<Tile, (int nationId, int distance)> tileAssignments = new();
        Queue<(Tile, int nationId, int distance)> popFrontier = new();

        for (int i = 0; i < chosenCapitals.Count; i++)
        {
            Tile capital = chosenCapitals[i];
            tileAssignments[capital] = (i, 0);
            popFrontier.Enqueue((capital, i, 0));
        }

        while (popFrontier.Count > 0)
        {
            var (current, nationId, dist) = popFrontier.Dequeue();

            foreach (string neighborStr in current.neighbors)
            {
                if (int.TryParse(neighborStr, out int neighborId) &&
                    tileByGameId.TryGetValue(neighborId, out Tile neighbor) &&
                    neighbor.controllerId == nationId &&
                    !tileAssignments.ContainsKey(neighbor))
                {
                    tileAssignments[neighbor] = (nationId, dist + 1);
                    popFrontier.Enqueue((neighbor, nationId, dist + 1));
                }
            }
        }

        Debug.Log("Step 6: Distance map created for population distribution.");

        // Step 7: Calculate and normalize weights
        Dictionary<int, double> nationWeightSums = new();
        Dictionary<Tile, double> tileWeights = new();

        foreach (var entry in tileAssignments)
        {
            Tile tile = entry.Key;
            int nationId = entry.Value.nationId;
            int dist = entry.Value.distance;

            double weight = 1.0 / ((dist + 1) * (dist + 1)); // Falloff function
            tileWeights[tile] = weight;

            if (!nationWeightSums.ContainsKey(nationId))
                nationWeightSums[nationId] = 0;

            nationWeightSums[nationId] += weight;
        }

        double totalWeight = 0;
        foreach (var sum in nationWeightSums.Values)
            totalWeight += sum;

        // Step 8: Assign population to each tile based on normalized weight
        foreach (var kvp in tileWeights)
        {
            Tile tile = kvp.Key;
            double weight = kvp.Value;
            int population = Mathf.RoundToInt((float)(weight / totalWeight * totalWorldPopulation));
            tile.stats.population = population;
            if (tile.type == Tile.TileType.Sea)
                continue;
            DatabaseControl.UpdateTilePopulation(int.Parse(tile.Id), gameId, population);
        }

        Debug.Log("Step 8: Population distributed and pushed to DB.");
    }


    public async Task UpdateTileOwnershipFromDatabaseAsync(int gameId)
    {
        await Task.Run(() =>
        {
            tiles = tilesParent.GetComponentsInChildren<Tile>();

            foreach (Tile tile in tiles)
            {
                DBTile dbTile = DatabaseControl.GetTileById(int.Parse(tile.Id), gameId);
                if (dbTile != null)
                {
                    int ownerId = dbTile.owner;
                    UnityMainThreadDispatcher.Enqueue(() =>
                    {
                        tile.controllerId = ownerId;
                    });
                }
            }
        });

        Debug.Log("Tile ownerships synced from database.");
    }

    public void InitializeAll()
    {
        tiles = tilesParent.GetComponentsInChildren<Tile>();

        foreach (Tile tile in tiles)
        {
            DBTile dbTile = DatabaseControl.GetTileById(int.Parse(tile.Id),MapDBInitializer.GameId);
            if (dbTile != null)
            {
                int ownerId = dbTile.owner;
                tile.controllerId = ownerId;
                tile.stats.population = dbTile.population;
            }
        }
    }
    

    // Update is called once per frame
    async void Update()
    {
        if (MapDBInitializer.isMapInitializing)
            return;
        
        if (!isInitialized &&!isLoaded)
        {
            isInitialized = true;
            isLoaded = true;
            await CreateRandomNationsAsync();
        }
        else if (!isLoaded)
        {
            print("Is already initialized. loading...");
            InitializeAll();
            isLoaded = true;
        }
    }


    public struct TileDataLite
    {
        public Tile tile;
        public Vector3 position;
    }


}